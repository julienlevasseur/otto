package localaddr

import (
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/otto/helper/oneline"
)

// CachedDB wraps a DB and caches the result of Next() into a local file,
// reusing that for the duration that it exists (and automatically renewing
// it).
//
// This is useful if you're consuming a single IP address and want a
// consistent IP address across runs.
type CachedDB struct {
	// DB is the underlying DB to use
	DB *DB

	// CachePath is the path to a file that will store the cached IP.
	CachePath string
}

// IP retrieves the IP address.
//
// If it is cached, it will renew and use that address. If it isn't cached,
// then it will grab a new IP, cache that, and use that.
func (db *CachedDB) IP() (net.IP, error) {
	log.Printf("[DEBUG] reading IP, cache path: %s", db.CachePath)

	// Try to read the cached version
	_, err := os.Stat(db.CachePath)
	if err == nil {
		raw, err := oneline.Read(db.CachePath)
		if err != nil {
			return nil, err
		}

		ip := net.ParseIP(raw)
		if ip != nil {
			log.Printf("[DEBUG] read ip from cache: %s", ip)
			db.DB.Renew(ip)
			return ip, nil
		}
	}

	// Make sure the directory to our cache path exists
	if err := os.MkdirAll(filepath.Dir(db.CachePath), 0755); err != nil {
		return nil, err
	}

	// No cached version.
	log.Printf("[DEBUG] no ip cache found, getting new IP")
	ip, err := db.DB.Next()
	if err != nil {
		return nil, err
	}

	contents := fmt.Sprintf(strings.TrimSpace(cacheContents)+"\n", ip.String())
	err = ioutil.WriteFile(db.CachePath, []byte(contents), 0644)
	if err != nil {
		db.DB.Release(ip)
		return nil, err
	}

	log.Printf("[DEBUG] new IP cached: %s", ip)
	return ip, nil
}

const cacheContents = `
%s

DO NOT EDIT THIS FILE!

The above is the IP address assigned to your development environment by
Otto. Otto keeps careful track of used IP addresses and editing this file
may corrupt its internal database of IP addresses.
`
